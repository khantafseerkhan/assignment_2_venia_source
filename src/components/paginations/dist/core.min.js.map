{"version":3,"sources":["core.js"],"names":["_react","_interopRequireWildcard","require","DOTS","range","start","end","length","Array","from","_","idx","usePagination","_ref","totalCount","pageSize","_ref$siblingCount","siblingCount","currentPage","useMemo","totalPageCount","Math","ceil","leftSiblingIndex","max","rightSiblingIndex","min","paginationRange","totalPageNumbers","lastPageIndex","shouldShowLeftDots","shouldShowRightDots","leftRange","concat","_toConsumableArray","rightRange","firstPageIndex","middleRange"],"mappings":"+VAAA,IAAAA,OAAAC,wBAAAC,QAAA,0kCAGO,IAAMC,KAAO,wBAEpB,IAAMC,MAAQ,SAACC,EAAOC,GACpB,IAAIC,EAASD,EAAMD,EAAQ,EAC3B,OAAOG,MAAMC,KAAK,CAAEF,OAAAA,GAAU,SAACG,EAAGC,GAAJ,OAAYA,EAAMN,KAGrCO,cAAgB,SAAAC,GAKvB,IAJJC,EAIID,EAJJC,WACAC,EAGIF,EAHJE,SAGIC,EAAAH,EAFJI,aAAAA,OAEI,IAAAD,EAFW,EAEXA,EADJE,EACIL,EADJK,YAmCI,OAjCoB,EAAAlB,OAAAmB,SAAQ,WAC9B,IAAMC,EAAiBC,KAAKC,KAAKR,EAAaC,GAZ5CX,GAASC,GAecY,EAAe,EAdtCV,OAAMH,MAAM,EAAGC,GACZ,IAAuBkB,EAAAF,KAAAG,IAAAN,EAAAD,EAAA,GAAAQ,EAAAJ,KAAAK,IAA9BR,EAAAD,EAFFG,GAWQO,EAA0B,EAARJ,EAChBH,EAAsBE,EAAkBP,EAE9C,EACMa,EAAmBX,EAEzBY,EAAAT,EAyBA,IAAKU,GAAsBC,EAAqB,CAC9C,IACIC,EAAY5B,MAAM,EADF,EAAI,EAAIa,GArB5B,MAAA,GAAAgB,OAAAC,mBAAO9B,GAAP,CAAgBgB,KAAAA,IAGlB,GAAMG,IAAuBQ,EAAmBd,CAChD,IAKAkB,EAAA/B,MAqBIgB,GA1BmB,EAAGC,EAAKK,GA0BO,EAClCN,GAEF,MAAA,CAAQgB,EAAgBjC,MAAxB8B,OAAAC,mBAAiCC,IAlBnC,GAAMJ,GAAsBN,EAAoBL,CAEhD,IAAMgB,EAAchC,MAApBmB,EAAAE,GACA,MAAA,CAAMI,EAAgBT,MAAtBa,OAAAC,mBAAAG,GAAA,CAAAlC,KAAA0B,MAEA,CAAAf,EAAKgB,EAADb,EAAuBc","file":"core.min.js","sourcesContent":["import React from 'react';\r\nimport { useMemo } from 'react';\r\n\r\nexport const DOTS = '...';\r\n\r\nconst range = (start, end) => {\r\n  let length = end - start + 1;\r\n  return Array.from({ length }, (_, idx) => idx + start);\r\n};\r\n\r\nexport const usePagination = ({\r\n  totalCount,\r\n  pageSize,\r\n  siblingCount = 1,\r\n  currentPage\r\n}) => {\r\n  const paginationRange = useMemo(() => {\r\n    const totalPageCount = Math.ceil(totalCount / pageSize);\r\n\r\n    // Pages count is determined as siblingCount + firstPage + lastPage + currentPage + 2*DOTS\r\n    const totalPageNumbers = siblingCount + 5;\r\n\r\n    /*\r\n      If the number of pages is less than the page numbers we want to show in our\r\n      paginationComponent, we return the range [1..totalPageCount]\r\n    */\r\n    if (totalPageNumbers >= totalPageCount) {\r\n      return range(1, totalPageCount);\r\n    }\r\n\r\n    const leftSiblingIndex = Math.max(currentPage - siblingCount, 1);\r\n    const rightSiblingIndex = Math.min(\r\n      currentPage + siblingCount,\r\n      totalPageCount\r\n    );\r\n\r\n    /*\r\n      We do not want to show dots if there is only one position left \r\n      after/before the left/right page count as that would lead to a change if our Pagination\r\n      component size which we do not want\r\n    */\r\n    const shouldShowLeftDots = leftSiblingIndex > 2;\r\n    const shouldShowRightDots = rightSiblingIndex < totalPageCount - 2;\r\n\r\n    const firstPageIndex = 1;\r\n    const lastPageIndex = totalPageCount;\r\n\r\n    if (!shouldShowLeftDots && shouldShowRightDots) {\r\n      let leftItemCount = 3 + 2 * siblingCount;\r\n      let leftRange = range(1, leftItemCount);\r\n\r\n      return [...leftRange, DOTS, totalPageCount];\r\n    }\r\n\r\n    if (shouldShowLeftDots && !shouldShowRightDots) {\r\n      let rightItemCount = 3 + 2 * siblingCount;\r\n      let rightRange = range(\r\n        totalPageCount - rightItemCount + 1,\r\n        totalPageCount\r\n      );\r\n      return [firstPageIndex, DOTS, ...rightRange];\r\n    }\r\n\r\n    if (shouldShowLeftDots && shouldShowRightDots) {\r\n      let middleRange = range(leftSiblingIndex, rightSiblingIndex);\r\n      return [firstPageIndex, DOTS, ...middleRange, DOTS, lastPageIndex];\r\n    }\r\n  }, [totalCount, pageSize, siblingCount, currentPage]);\r\n\r\n  return paginationRange;\r\n};"]}